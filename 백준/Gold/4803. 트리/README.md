# [Gold IV] 트리 - 4803 

[문제 링크](https://www.acmicpc.net/problem/4803) 

### 성능 요약

메모리: 115872 KB, 시간: 224 ms

### 분류

자료 구조(data_structures), 깊이 우선 탐색(dfs), 분리 집합(disjoint_set), 그래프 이론(graphs), 그래프 탐색(graph_traversal), 트리(trees)

### 풀이 과정

그래프에서의 순환 발생 여부를 확인하는 문제이다. 
전형적인 유니온-파인드 문제로 간선정보를 입력받아 상호베타 집합을 관리하여 그래프가 몇개의 트리로 구성되었는지 구할 수 있다.
이때 순환이 발생했다는 것은 동일한 집한에 속한 원소끼리 union을 시켰음을 의미한다.
따라서 union 함수를 수정하여 find[a]==find[b]인 경우 해당 집합의 루트값을 -1로 변경하였다.
간선 정보에 따라 parent 배열을 수정한 후 경로가 갱신되지 않은 노드가 있을 수 있기에 각 노드에 대한 find(경로 단축을 적용한)를 수행해 주었다.
set을 통해 중복을 제거해 몇개의 트리가 존재하는지 알 수 있었다.

### 구현 과정

구현 과정에서 놓쳤던 부분이 하나 있다. 바로 union을 수정해주면서 find[a]==find[b]==-1인 경우를 생각하지 못하였다.
처음에 find[a]==find[b](순환)인 경우에 find[a]=-1 을 해주었는데 두개의 순환끼리 연결해주는 경우에 find[-1]을 참조하여 되어 -1로 수정해주는 오류가 발생한다.
유니온 파인드는 자주 푸는 유형이 아니기에 구현과정에서 놓치는 부분들이 존재한다. 이런 경우에는 알고리즘 로직을 수정하는 것보다.
기본 알고리즘으로 해당 문제의 상황에 적절히 적용하여 푸는 것이 정확성 면에서 더 낫겠다고 느꼈다.
그냥 유니온을 수정하여 parent배열에 -1을 넣는게 아닌 순환이 발생할 경우 해당 루트 값을 순환하는 집합을 저장하는 리스트에 넣어 주었다면 실수를 하지 않았을 것이다.
기본 로직을 수정하는 과정에서 실수가 발생할 수 있음을 유의하고 문제풀이에 임해야할 것이다.
