# [Gold IV] 뱀 - 3190 

[문제 링크](https://www.acmicpc.net/problem/3190) 

### 성능 요약

메모리: 116476 KB, 시간: 156 ms

### 분류

자료 구조(data_structures), 덱(deque), 구현(implementation), 큐(queue), 시뮬레이션(simulation)

### 풀이 과정
 
처음에 떠오른 구현 방식은 직관적인 방법인 매초마다 뱀이 한칸씩 움직이는 것을 시뮬레이션 하는것이다.
보통 시뮬레이션에서 매초마다의 동작이 일일이 발생하게 구현한다면 시간초과가 발생한다.
하여 주어진 X와 C를 이용해 방향전환이 발생할 때마다의 뱀의 움직임만을 고련한 시뮬레이션 구현에 대해 고민하였다.
그러나 매초마다 뱀이 존재하는 공간이 변화한다. 즉, 현재 방향으로 방향전환 이 발생하기 전까지 M칸 나아간다고 했을 때
그 M칸사이에 뱀이 몸이 있었다가 없을 수도 있기에 신경써야할 부분이 너무 많고 복잡해져 구현을 어떻게 해야할지 대략난감하다;;
구현이 힘들다 판단하여 구현이 쉬운 첫번째 방식인 매초마다의 시뮬레이션 방식의 시간복잡도를 고려하였다.
머리에서 몇가지 시뮬레이션을 돌려보니 최악의 상황은 100x100크기 보드에서 뱀이 테두리를 빙글빙글 도는 경우일거라 생각함.
왜냐하면, 뱀이 방향 전환 없이 나아갈 수 있는 최대 거리는 대략 100임(X의 최대값은 10000이지만 보드 크기때문에 의미없음)
즉, 최악의 경우는 테두리를 빙글빙글 돌며 한번의 방향전환당 100씩 이동하는 것이고 즉, Big O는 대략 10000정도의 시행이 발생.
매초 시뮬레이션 돌려봤자 10000의 시행이면 시간복잡도 초과하지 않음. 이러한 사고 과정을 통해 풀이를 생각하였음

### 구현 과정
처음에는 뱀의 head좌표와 tail좌표와 현재 머리가 향하는 방향만을 생각하며 구현하였다.
근데 이러면 머리가 나아가는 방향은 맞지만 tail이 나아가는 방향은 틀리게된다.
왜냐하면 머리가 향하는 방향이 바뀌어도 뱀은 계속 몸통쪽을 보며 줄어들어야 하기 때문이다.
그럼 꼬리의 방향을 따로 만들어서 구현하면 되나? 싶었다. 하지만 이렇게 되면 몇초후에 꼬리의 방향이 바뀌어야 하는지도 알고 있어야 한다. 
너무 복잡해진다. 그래서 생각한것이 리스트에 뱀의 모든 위치들을 다 저장하는 방식이다. 이렇게 다 저장해놓고 그냥 꼬리 부부인 snake[0]의 위치를
보드에서 비워주고 0번 원소를 제거해주면 된다. 근데 이런 동작방식은 FIFO이므로 큐로 구현해주는 것이 효율성에 좋으니 뱀을 큐로 구현하였다.




