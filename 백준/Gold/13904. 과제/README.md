# [Gold III] 과제 - 13904 

[문제 링크](https://www.acmicpc.net/problem/13904) 

### 성능 요약

메모리: 114328 KB, 시간: 124 ms

### 분류

자료 구조(data_structures), 그리디 알고리즘(greedy), 우선순위 큐(priority_queue), 정렬(sorting)

### 풀이 과정

과제의 시작일이 동일하고 기한만 다른 상황이다. 그리디한 접근법으로 선정되는 task가 기한의 마지막날 수행되는 것이 최적일 것이다.
또한, 하루에 하나의 task가 선정되므로 점수가 가장 높은 task부터 기한 마지막 날에 선정해주는 것이 최적의 방식이다.
그런데 이렇게 수행하다 보면 x번째날 task가 선정되고 그 다음으로 점수가 높은 task의 마지막 날이 x번째로 동일한 경우에 대해 생각해주어야 한다.
이런 경우에는 해당 task를 x-1번째날 선정해주는 것이 최적일 것이고 x-1번째에 task가 이미 선정된 경우 x-2번째 선정해주는 것이 최적이다.
이렇게 하루씩 앞당겨서 선정해주다 1일 까지 꽉 차있으면 해당 task는 버려주면 되는것이다.

### 구현 과정

위의 로직을 수행하기위해 점수가 가장 높은 task부터 처리해주도록 task들을 점수에 의한 내림차순으로 정렬해주었다. 그리고 순차적으로 기한 마지막날일 비어 있으면 task를 선정해주고
해당 기한이 차있으면 그 전날을 순차적으로 탐색하여 빈 날을 찾아 task를 선정해주도록 구현해 주었다.
task와 기한의 최대값이 각각 1000이기에 최악의 경우를 고려해봤을 때 기한이 모두 1000일인 task가 1000개 주워진다면 1+2+...+999+1000의 수행이 발생할 것이다.
즉, O(N^2)이고 정렬은 NlogN이기에 위 로직의 O(N^2)이다. N=1000이기에 효율성 초과는 발생하지 않는다.
위의 방식말고 pq를 이용한 풀이가 존재한다. 하지만 pq에 N개의 task를 넣으면 heap구조를 유지하기위해 정렬과 같은 nlogn의 계산이 발생하고 위의 최악의 상황이 주어진 경우 동일한
N^2의 복잡도가 발생한다. 
